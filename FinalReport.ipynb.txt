{
 "cells": [
  {
   "cell_type": "markdown",
   "metadata": {
    "collapsed": true
   },
   "source": [
    "## P0 Compiler Optimization: Draft Report\n",
    "#### COMP SCI 4TB3/6TB3, McMaster University\n",
    "#### Original Author: Emil Sekerinski, February 2017\n",
    "---\n",
    "#### Optimization Authors: Sherwin Chang (001426383), Arian Sohrabi (001409334)\n",
    "#### Date: April 2017\n",
    "---\n",
    "\n",
    "## Optimization Draft Report\n",
    "\n",
    "When working with computers, it is easy to have inefficient codes likely due to ease of understanding. As such, when program size grows, the runtime speed will suffer and results in a slower program. The goal of the 'P0 Compiler Optimization' is to implement various optimization techiniques on the code generated by the P0 compiler. At the current state, the P0 compiler already have implemented some optimization techniques (i.e. constant folding and constant propagation), the plan is to expand on these techniques. Doing this will in turn improve the speed at runtime, but will be done at the cost of overall code length and/or \"cleanliness\".\n",
    "\n",
    "##### Assumptions\n",
    "The optimization makes assumption that the optimization techniques will be applied for the MIPS code generated by the compiler, and not for the compiler itself.\n"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### Optimization Techniques\n",
    "The below will list the various optimization techniques that is planned to be implemented.\n",
    "\n",
    "Note: Each optimization will have an examples done in python to help explain how the technique works.\n",
    "\n",
    "##### Organization\n",
    "The optimizations of the report will be organized in this order.\n",
    "\n",
    "Description >> Python code demonstration >> MIPS code before implementation >> Explaination of implementation >> Testing of Implementation. "
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 2,
   "metadata": {
    "collapsed": false
   },
   "outputs": [],
   "source": [
    "import nbimporter\n",
    "from P0 import compileString"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "#### Integer Multiply/Divide Optimization\n",
    "Integer multiplication and division can be replaced with a shift operation if one of the operands is a power of two. Shift operations are faster than multiply on mips architectue, therefor this will reduce the running time of the executable."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 3,
   "metadata": {
    "collapsed": false
   },
   "outputs": [],
   "source": [
    "def before (n): #Multiplication\n",
    "    return n * 2\n",
    "\n",
    "def after (n):\n",
    "    return n << 1"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 4,
   "metadata": {
    "collapsed": true
   },
   "outputs": [],
   "source": [
    "def before (n): #Division\n",
    "    return n / 2\n",
    "\n",
    "def after (n):\n",
    "    return n >> 1"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "The following shows the MIPS Code before optimization of the example provided below.\n",
    "```\n",
    "    .data\n",
    "z_: .space 4\n",
    "y_: .space 4\n",
    "x_: .space 4\n",
    "    .text\n",
    "    .globl main\n",
    "    .ent main\n",
    "main:\n",
    "\taddi $t7, $0, 3\n",
    "\tsw $t7, x_\n",
    "    lw $t8, x_\n",
    "\tmul $t8, $t8, 4\n",
    "\tsw $t8, x_\n",
    "    addi $t2, $0, 4\n",
    "    sw $t2, y_\n",
    "    lw $t6, x_\n",
    "    div $t6, $t6, 4\n",
    "    sw $t6, z_\n",
    "    lw $t5, x_\n",
    "    lw $t0, y_\n",
    "    div $t5, $t5, $t0\n",
    "    sw $t5, x_\n",
    "    li $v0, 10\n",
    "    syscall\n",
    "    .end main\n",
    "```"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "In order to implement the Integer Multiply/Divide Optimization, changes are needed to be made in...\n",
    "\n",
    "The code below should now generate an optimized MIPS code."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 22,
   "metadata": {
    "collapsed": false
   },
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "\t.data\n",
      "z_:\t.space 4\n",
      "y_:\t.space 4\n",
      "x_:\t.space 4\n",
      "\t.text\n",
      "\t.globl main\n",
      "\t.ent main\n",
      "main:\t\n",
      "\taddi $t7, $0, 3\n",
      "\tsw $t7, x_\n",
      "\tlw $t8, x_\n",
      "\tmul $t8, $t8, 4\n",
      "\tsw $t8, x_\n",
      "\taddi $t2, $0, 4\n",
      "\tsw $t2, y_\n",
      "\tlw $t6, x_\n",
      "\tdiv $t6, $t6, 4\n",
      "\tsw $t6, z_\n",
      "\tlw $t5, x_\n",
      "\tlw $t0, y_\n",
      "\tdiv $t5, $t5, $t0\n",
      "\tsw $t5, x_\n",
      "\tli $v0, 10\n",
      "\tsyscall\n",
      "\t.end main\n"
     ]
    }
   ],
   "source": [
    "compileString(\"\"\"\n",
    "program p;\n",
    "  var x, y, z: integer;\n",
    "  begin x := 3;\n",
    "    x := x * 4;\n",
    "    y := 4;\n",
    "    z := x div 4;\n",
    "    x := x div y\n",
    "  end\n",
    "\"\"\")"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "#### Arithmetic Code Optimization"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "In arithmetics calculations, some constant calculations can be reduced to exclude redundant calculations. Such as with adding and subtracting by 0, multipling and dividing by 1, and multipling by 0  (Some of this is done for Lab 11)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "collapsed": true
   },
   "outputs": [],
   "source": [
    "def before (n): #Multiplication\n",
    "    x = 1 + 0\n",
    "    x = 0 + x\n",
    "    x = x - 0\n",
    "    x = x * 1\n",
    "    x = 1 * x\n",
    "    x = x / 1\n",
    "    x = x * 0\n",
    "    \n",
    "def after (n):\n",
    "    x = 1\n",
    "    x = x\n",
    "    x = x\n",
    "    x = x\n",
    "    x = x\n",
    "    x = x\n",
    "    x = 0"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "The example provided would have generated the following MIPS code.\n",
    "```\n",
    "\t.data\n",
    "y_: .space 4\n",
    "x_: .space 4\n",
    "\t.text\n",
    "\t.globl main\n",
    "\t.ent main\n",
    "main:\t\n",
    "    addi $t7, $0, 5\n",
    "    sw $t7, x_\n",
    "    lw $t8, x_\n",
    "    add $t8, $t8, 0\n",
    "    sw $t8, y_\n",
    "    lw $t6, y_\n",
    "    add $t2, $0, $t6\n",
    "    sw $t2, x_\n",
    "    lw $t5, x_\n",
    "    mul $t5, $t5, 1\n",
    "    sw $t5, y_\n",
    "    addi $t0, $0, 1\n",
    "    lw $t3, y_\n",
    "    mul $t0, $t0, $t3\n",
    "    sw $t0, x_\n",
    "    lw $t1, x_\n",
    "    add $t1, $t1, 3\n",
    "    sw $t1, y_\n",
    "    addi $t4, $0, 3\n",
    "    lw $t7, y_\n",
    "    add $t4, $t4, $t7\n",
    "    sw $t4, x_\n",
    "    lw $t8, x_\n",
    "    div $t8, $t8, 1\n",
    "    sw $t8, y_\n",
    "    lw $t2, x_\n",
    "    mul $t2, $t2, 0\n",
    "    sw $t2, x_\n",
    "    li $v0, 10\n",
    "    syscall\n",
    "    .end main\n",
    "```"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Explaination....."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 26,
   "metadata": {
    "collapsed": false
   },
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "\t.data\n",
      "y_:\t.space 4\n",
      "x_:\t.space 4\n",
      "\t.text\n",
      "\t.globl main\n",
      "\t.ent main\n",
      "main:\t\n",
      "\taddi $t7, $0, 5\n",
      "\tsw $t7, x_\n",
      "\tlw $t8, x_\n",
      "\tadd $t8, $t8, 0\n",
      "\tsw $t8, y_\n",
      "\tlw $t6, y_\n",
      "\tadd $t2, $0, $t6\n",
      "\tsw $t2, x_\n",
      "\tlw $t5, x_\n",
      "\tmul $t5, $t5, 1\n",
      "\tsw $t5, y_\n",
      "\taddi $t0, $0, 1\n",
      "\tlw $t3, y_\n",
      "\tmul $t0, $t0, $t3\n",
      "\tsw $t0, x_\n",
      "\tlw $t1, x_\n",
      "\tadd $t1, $t1, 3\n",
      "\tsw $t1, y_\n",
      "\taddi $t4, $0, 3\n",
      "\tlw $t7, y_\n",
      "\tadd $t4, $t4, $t7\n",
      "\tsw $t4, x_\n",
      "\tlw $t8, x_\n",
      "\tdiv $t8, $t8, 1\n",
      "\tsw $t8, y_\n",
      "\tlw $t2, x_\n",
      "\tmul $t2, $t2, 0\n",
      "\tsw $t2, x_\n",
      "\tli $v0, 10\n",
      "\tsyscall\n",
      "\t.end main\n"
     ]
    }
   ],
   "source": [
    "compileString(\"\"\"\n",
    "program p;\n",
    "  var x, y: integer;\n",
    "  begin x := 5;\n",
    "    y := x + 0;\n",
    "    x := 0 + y;\n",
    "    y := x * 1;\n",
    "    x := 1 * y;\n",
    "    y := x + 3;\n",
    "    x := 3 + y;\n",
    "    y := x div 1;\n",
    "    x := x * 0\n",
    "  end\n",
    "\"\"\")"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "#### Dead Code Elimination\n",
    "Some code comes off as being redundant, unused, or unreachable. As such, they can be elimited without having an effect on the program."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 27,
   "metadata": {
    "collapsed": false
   },
   "outputs": [],
   "source": [
    "g = 0\n",
    "\n",
    "def before():\n",
    "    n = 0 #unused variable\n",
    "    k = 1 \n",
    "    k = k - 1 #redundant statement\n",
    "    g = 2 #unused change\n",
    "    g = 3\n",
    "    g = 3 #redundant statement\n",
    "    return k\n",
    "    g = 4 #unreachable statement\n",
    "\n",
    "def after():\n",
    "    k = 0\n",
    "    g = 3\n",
    "    return k"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "#### If-Statement Elimination\n",
    "After compiliation, it can be determined if some of the if-statements takes a constant boolean as the expression (with help of constant folding). When that is the case it is no longer necessary to generate an if-statment. (This is done for Lab 11)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "collapsed": true
   },
   "outputs": [],
   "source": [
    "def before():\n",
    "    g = 0\n",
    "    k = 1\n",
    "    if True:\n",
    "        if g > k:\n",
    "            return 0\n",
    "        if False: \n",
    "            return 1\n",
    "        else:\n",
    "            return 2\n",
    "    else:\n",
    "        return 3\n",
    "    \n",
    "    \n",
    "def after():\n",
    "    return 2"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "The example provided is a modified version of the Lab Question 2. And the MIPS code shown below is before the optimization.\n",
    "```\n",
    "    .data\n",
    "x_: .space 4\n",
    "\t.text\n",
    "\t.globl main\n",
    "\t.ent main\n",
    "main:\t\n",
    "    addi $t7, $0, 1\n",
    "    addi $t8, $0, 2\n",
    "    ble $t7, $t8, L1\n",
    "L2:\t\n",
    "    addi $t2, $0, 1\n",
    "    beq $t2, $0, L3\n",
    "L4:\n",
    "    addi $t6, $0, 3\n",
    "    sw $t6, x_\n",
    "    b, L5\n",
    "L3:\t\n",
    "    addi $t5, $0, 5\n",
    "    sw $t5, x_\n",
    "L5:\t\n",
    "\tb, L6\n",
    "L1:\t\n",
    "    beq $0, $0, L7\n",
    "L8:\t\n",
    "    addi $t0, $0, 7\n",
    "    sw $t0, x_\n",
    "    b, L9\n",
    "L7:\t\n",
    "    addi $t3, $0, 9\n",
    "    sw $t3, x_\n",
    "L9:\t\n",
    "L6:\t\n",
    "\tbne $0, $0, L10\n",
    "L11:\t\n",
    "\taddi $t1, $0, 1\n",
    "\tbeq $t1, $0, L12\n",
    "L13:\t\n",
    "    addi $t4, $0, 11\n",
    "    sw $t4, x_\n",
    "    b, L14\n",
    "L12:\t\n",
    "    addi $t7, $0, 13\n",
    "    sw $t7, x_\n",
    "L14:\t\n",
    "    b, L15\n",
    "L10:\t\n",
    "    beq $0, $0, L16\n",
    "L17:\t\n",
    "    addi $t8, $0, 15\n",
    "    sw $t8, x_\n",
    "    b, L18\n",
    "L16:\t\n",
    "    addi $t2, $0, 17\n",
    "    sw $t2, x_\n",
    "L18:\t\n",
    "L15:\t\n",
    "    li $v0, 10\n",
    "    syscall\n",
    "    .end main\n",
    "```"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Explaination.........."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 31,
   "metadata": {
    "collapsed": false
   },
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "\t.data\n",
      "x_:\t.space 4\n",
      "\t.text\n",
      "\t.globl main\n",
      "\t.ent main\n",
      "main:\t\n",
      "\taddi $t7, $0, 1\n",
      "\taddi $t8, $0, 2\n",
      "\tble $t7, $t8, L1\n",
      "L2:\t\n",
      "\taddi $t2, $0, 1\n",
      "\tbeq $t2, $0, L3\n",
      "L4:\t\n",
      "\taddi $t6, $0, 3\n",
      "\tsw $t6, x_\n",
      "\tb, L5\n",
      "L3:\t\n",
      "\taddi $t5, $0, 5\n",
      "\tsw $t5, x_\n",
      "L5:\t\n",
      "\tb, L6\n",
      "L1:\t\n",
      "\tbeq $0, $0, L7\n",
      "L8:\t\n",
      "\taddi $t0, $0, 7\n",
      "\tsw $t0, x_\n",
      "\tb, L9\n",
      "L7:\t\n",
      "\taddi $t3, $0, 9\n",
      "\tsw $t3, x_\n",
      "L9:\t\n",
      "L6:\t\n",
      "\tbne $0, $0, L10\n",
      "L11:\t\n",
      "\taddi $t1, $0, 1\n",
      "\tbeq $t1, $0, L12\n",
      "L13:\t\n",
      "\taddi $t4, $0, 11\n",
      "\tsw $t4, x_\n",
      "\tb, L14\n",
      "L12:\t\n",
      "\taddi $t7, $0, 13\n",
      "\tsw $t7, x_\n",
      "L14:\t\n",
      "\tb, L15\n",
      "L10:\t\n",
      "\tbeq $0, $0, L16\n",
      "L17:\t\n",
      "\taddi $t8, $0, 15\n",
      "\tsw $t8, x_\n",
      "\tb, L18\n",
      "L16:\t\n",
      "\taddi $t2, $0, 17\n",
      "\tsw $t2, x_\n",
      "L18:\t\n",
      "L15:\t\n",
      "\tli $v0, 10\n",
      "\tsyscall\n",
      "\t.end main\n"
     ]
    }
   ],
   "source": [
    "compileString(\"\"\"\n",
    "program p;\n",
    "  var x: integer;\n",
    "  begin\n",
    "    if 1 > 2 then\n",
    "      if true then x := 3 else x := 5\n",
    "    else\n",
    "      if false then x := 7 else x := 9;\n",
    "    if 0 = 0 then\n",
    "      if true then x := 11 else x := 13\n",
    "    else\n",
    "      if false then x := 15 else x := 17\n",
    "  end\n",
    "\"\"\")"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "#### Unswitching\n",
    "When there are switch statements (if/else) inside loops, the switch statements can be moved outside of the loop as long as the switch conditions does not require a variable that is affected by the loop."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "collapsed": true
   },
   "outputs": [],
   "source": [
    "def before(x):\n",
    "    a = 0\n",
    "    b = 10\n",
    "    c = True\n",
    "    while (a < b):\n",
    "        if c:\n",
    "            a += 1\n",
    "            x[a] = 5\n",
    "        else:\n",
    "            a += 1\n",
    "            x[a] = -5\n",
    "\n",
    "def after(x):\n",
    "    a = 0\n",
    "    b = 10\n",
    "    c = True\n",
    "    if c:\n",
    "        while (a < b):\n",
    "            a += 1\n",
    "            x[a] = 5\n",
    "    else:\n",
    "        while (a < b):\n",
    "            a += 1\n",
    "            x[a] = -5"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "#### Loop-Invariant Code Motion\n",
    "When a loop has loop-invariant codes--codes which have the same value before and after the loop--they can be move outside of the loop. So that they do not have to ran with every iteration of the loop."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "collapsed": true
   },
   "outputs": [],
   "source": [
    "def before (i):\n",
    "    while True:\n",
    "        a = 5\n",
    "        b = a + a\n",
    "        c = i / 2\n",
    "        if i == 10:\n",
    "            return a + b + c\n",
    "        i += 1\n",
    "        \n",
    "def after (i):\n",
    "    a = 5 #a and b never changes\n",
    "    b = a + a\n",
    "    while True:\n",
    "        c = i / 2\n",
    "        if i == 10:\n",
    "            return a + b + c\n",
    "        i += 1"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "#### Common Subexpression Elimination\n",
    "In some expressions, a duplicate sequence can occur (they have common subexpression). Compiler should be able to recognize the duplication and just calculate the sequence one time."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 24,
   "metadata": {
    "collapsed": true
   },
   "outputs": [],
   "source": [
    "def before (a,b,c,d):\n",
    "    return (a*b)-(a*b)/(b+c*d)\n",
    "        \n",
    "def after (a,b,c,d):\n",
    "    t = (a*b)\n",
    "    return t-t/(b+c*d)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "#### Instruction Combining\n",
    "There are many operations that can be combined into a single operation, such as additions and subtraction."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 25,
   "metadata": {
    "collapsed": true
   },
   "outputs": [],
   "source": [
    "def before ():\n",
    "    x = 1+2\n",
    "    x += 3\n",
    "    return x\n",
    "        \n",
    "def after ():\n",
    "    x = 1+2+3 # or x = 6\n",
    "    return x"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### Referenes\n",
    "http://www.compileroptimizations.com\n",
    "\n",
    "https://en.wikipedia.org/wiki/Optimizing_compiler"
   ]
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "Python 3",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.6.0"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 2
}
